import numpy as np

states = ['Upper East Side', 'Upper West Side', 'East Harlem', 'Harlem', 'Washington Heights', 'Chelsea', "Hell's Kitchen", 'Midtown', 'Midtown East', 'Murray Hill and Gramercy', 'East Village', 'West Village', 'Greenwich Village', 'Financial District', 'Lower East Side', 'Soho', 'Central Park', 'Laguardia Airport', 'JFK Airport']

actions = ['North','South','East','West','Commit']

numStates = len(states)

"""
create a matrix with rows representing neighborhoods, and columns for north east south west, 
with entries encoding which neighborhood you end up in if you are in neighborhood i and drive in direction j
"""
trans = np.array([
        ['East Harlem',0,'Midtown East','Central Park'],            #Upper East
        ['Harlem','Central Park',"Hell's Kitchen",0],               #Upper West
        ['Washington Heights',0, 'Upper East Side', 'Harlem'],          #etc.
        ['Washington Heights','East Harlem','Upper West Side',0],
        [0,'East Harlem',0,'East Harlem'],
        ["Hell's Kitchen",'Murray Hill and Gramercy', 'West Village',0],
        ['Upper West Side','Midtown','Chelsea',0],
        ['Central Park','Midtown East','Murray Hill and Gramercy',"Hell's Kitchen"],
        ['Upper East Side',0,'Murray Hill and Gramercy', 'Midtown'],
        ['Midtown East',0, 'East Village','Chelsea'],
        ['Murray Hill and Gramercy',0,'Lower East Side','Greenwich Village'],
        ['Chelsea','Greenwich Village','Soho',0],
        ['Chelsea','East Village','Soho','West Village'],
        [0,'Lower East Side',0,'Soho'],
        ['East Village',0,'Financial District','Soho'],
        ['West Village','Lower East Side','Financial District',0],
        ['Harlem', 'Upper East Side','Midtown','Upper West Side'],
        [0,0,0,0],              #Laguardia
        [0,0,0,0                #JFK
    ])

def determ_transition(newState):
    """function used for deterministic transition, will return a list of tuples [(state1,0),(state2,0),...(newState,1),...] """
    index = states.index(newState)
    probs = [0]*(index)+[1]+[0]*(numStates-index-1) 
    return zip(states,probs)

"""uses the trans matrix to look up successor state for deterministic 'drive away' """
def successorState(state, action):
        row = states.index(state)
        #col = [0 if action=='North' else 1 if action='=East' else 2 if action=='South' else 3 if action==West]
        col= 0
        if action=='East':
            col = 1
        elif action=='South':
            col = 2
        elif action=='West':
            col = 3
        return trans[row][col]

def T(state, action):
    """Transition model.  From a state and an action, return a list
    of (result-state, probability) pairs."""
    if action = 'Commit':
        keys = transitionModel[state].keys() #all the next states
        probs = [item[0] for item in transitionModel[state].values()] #the prob values of the next states
        return zip(keys,probs) #return the tuple
    #else choose to drive elsewhere    
    else: 
        newState = successorState(state,action)
        if newState==0:
            return determ_transition(state)
        else:
            return determ_transition(newState)

# def commit_expect(state):
#     expectations = [item[0]*item[1] for item in transitionModel[state].values()]
#     return sum(expectations)

"""
defining R(s,a,s')
"""
def R(self, state, action, state1):
    "Return a numeric reward for this state."
    if action = 'Commit':
        return transitionmodel[state][state1][1]
    else:
        newState=successorState(state,action)
        return transitionmodel[state][newState][1]

#think value iteration is good to go
def value_iteration(epsilon=0.001):
    "Solving an MDP by value iteration."
    U1 = dict([(s, 0) for s in states])
    gamma = .9
    while True:
        U = U1.copy()
        delta = 0
        for s in states:
            U1[s] = max([sum([p *(R(s,a,s1)*gamma*U[s1]) for (p, s1) in T(s, a)])
                                        for a in actions])
            delta = max(delta, abs(U1[s] - U[s]))
        if delta < epsilon * (1 - gamma) / gamma:
             return U
